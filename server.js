// server.js — Human-sounding barbershop phone agent (Twilio Media Streams + Deepgram + OpenAI + Make + ElevenLabs)
// Node v22.x compatible

"use strict";

const express = require("express");
const http = require("http");
const { WebSocketServer } = require("ws");
const fetch = (...args) => import("node-fetch").then(({ default: f }) => f(...args));

// ============ ENV ============
const PORT = process.env.PORT || 10000;
const LOCAL_TZ = process.env.LOCAL_TZ || "America/New_York";

const OPENAI_API_KEY = process.env.OPENAI_API_KEY || "";
const DG_API_KEY = process.env.DEEPGRAM_API_KEY || "";
const ELEVEN_API_KEY = process.env.ELEVEN_API_KEY || "";
const ELEVEN_VOICE_ID = process.env.ELEVEN_VOICE_ID || "";

// Make hooks
const MAKE_CREATE = process.env.MAKE_CREATE || "https://hook.us2.make.com/7hd4nxdrgytwukxw57cwyykhotv6hxrm";
const MAKE_READ   = process.env.MAKE_READ   || "https://hook.us2.make.com/6hmur673mpqw4xgy2bhzx4be4o32ziax";
const MAKE_DELETE = process.env.MAKE_DELETE || "https://hook.us2.make.com/noy0e27knj7e1jlomtznw34z246i3xtv";

// Render prompt (paste your long policy here or set env AGENT_PROMPT)
const FALLBACK_PROMPT = `
You are a friendly, human-sounding AI receptionist for Old Line Barbershop.
Your job is to answer the phone, sound natural, and help customers with the same tasks a real receptionist would handle.

Core Responsibilities
- Greet callers warmly and always say the business name right away. Example: “Hi, thanks for calling Old Line Barbershop. How can I help you today?”
- Answer common questions clearly and directly (hours, pricing, services, location, etc.).
- Handle scheduling: booking, rescheduling, and cancellations.

Rules
- Short, natural sentences; one question max per turn; vary phrasing.
- Greet exactly once per call. After that, never greet again.
- Keep FAQs separate from booking unless caller explicitly wants to book (or agrees after FAQ).
- If you don’t know, say you’ll transfer and end the call.
- Always follow booking order: service → date/time → check availability → name & phone (confirm caller ID if present) → finalize.
- Only book Mon–Fri 9–5 (${LOCAL_TZ}). Never double-book.
- Keep caller informed (“Let me check… / That time is available… / You’re confirmed.”).

FAQ patterns
- Hours: “We’re open Monday–Friday, 9–5, closed weekends. Want me to book a time?”
- Pricing: “A haircut is $30, a beard trim is $15, or $40 for both. Want to schedule one?”
- Services: “We offer haircuts, beard trims, and combo packages. Want me to check availability?”
- Location: “We’re at 123 Blueberry Lane. Want to book a visit?”

Booking details
- Title: [Service] – [Customer Name]
- Time: [Start] → [Start + 30m]
- Description: Name, Phone, Service
- Confirm details, thank, say goodbye, and hang up immediately after booking.

Tone
- Friendly, professional, natural. One line at a time. All caller-facing lines are generated by you (no canned phrasing, no re-greetings).
`.trim();

const AGENT_PROMPT = process.env.AGENT_PROMPT ? String(process.env.AGENT_PROMPT) : FALLBACK_PROMPT;

// ============ LOG ============
const log = (...a) => console.log(new Date().toISOString(), "-", ...a);
const err = (...a) => console.error(new Date().toISOString(), "!", ...a);

// ============ TIME ============
function nowContext() { return { nowISO: new Date().toISOString(), tz: LOCAL_TZ }; }
function pretty(dtISO, tz = LOCAL_TZ) {
  try {
    return new Intl.DateTimeFormat("en-US", {
      timeZone: tz,
      year: "numeric", month: "short", day: "2-digit",
      hour: "numeric", minute: "2-digit"
    }).format(new Date(dtISO));
  } catch { return dtISO; }
}
function isBusinessHours(dtISO, tz = LOCAL_TZ) {
  const d = new Date(dtISO);
  if (isNaN(d.getTime())) return false;
  const dayShort = new Intl.DateTimeFormat("en-US", { weekday: "short", timeZone: tz }).format(d);
  const hour24 = Number(new Intl.DateTimeFormat("en-US", { hour: "numeric", hour12: false, timeZone: tz }).format(d));
  return ["Mon","Tue","Wed","Thu","Fri"].includes(dayShort) && hour24 >= 9 && hour24 < 17;
}

// ============ μ-law → PCM16 ============
function ulawByteToPcm16(u) {
  u = ~u & 0xff;
  const sign = u & 0x80;
  const exp = (u >> 4) & 0x07;
  const man = u & 0x0f;
  let sample = (((man << 3) + 0x84) << (exp + 2)) - 0x84 * 4;
  if (sign) sample = -sample;
  if (sample > 32767) sample = 32767;
  if (sample < -32768) sample = -32768;
  return sample;
}
function ulawBufferToPCM16LEBuffer(ulawBuf) {
  const out = Buffer.alloc(ulawBuf.length * 2);
  for (let i = 0; i < ulawBuf.length; i++) out.writeInt16LE(ulawByteToPcm16(ulawBuf[i]), i * 2);
  return out;
}

// ============ Deepgram Realtime ============
function startDeepgram({ onOpen, onPartial, onFinal, onError, onAny }) {
  const WebSocket = require("ws");
  if (!DG_API_KEY) { log("(!) No DEEPGRAM_API_KEY — ASR disabled."); return null; }

  const url = "wss://api.deepgram.com/v1/listen"
    + "?encoding=linear16&sample_rate=8000&channels=1"
    + "&model=nova-2-phonecall&interim_results=true&smart_format=true"
    + "&language=en-US&endpointing=150";

  const dg = new WebSocket(url, { headers: { Authorization: `Token ${DG_API_KEY}` }, perMessageDeflate: false });
  let open = false;
  const q = [];

  dg.on("open", () => { open = true; log("[ASR] Deepgram open"); onOpen?.(); while (q.length) { try { dg.send(q.shift()); } catch {} }});
  dg.on("message", (data) => {
    let msg; try { msg = JSON.parse(data.toString()); } catch { return; }
    onAny?.(msg);
    if (msg.type !== "Results") return;
    const alt = msg.channel?.alternatives?.[0];
    const txt = (alt?.transcript || "").trim();
    if (!txt) return;
    if (msg.is_final || msg.speech_final) { log("[ASR final]", txt); onFinal?.(txt); }
    else { onPartial?.(txt); }
  });
  dg.on("error", (e) => { onError?.(e); });
  dg.on("close", (c, r) => log("[ASR] closed", c, r?.toString?.() || ""));

  return {
    sendPCM16LE(buf) {
      try { if (open && dg.readyState === 1) dg.send(buf); else q.push(buf); }
      catch (e) { err("[ASR send]", e?.message || e); }
    },
    close() { try { dg.close(); } catch {} }
  };
}

// ============ Make helpers ============
async function callMake(url, payload, tag) {
  const json = JSON.stringify(payload);
  log(`[Make ${tag}] POST ${url} body(${json.length}B):`, json);
  try {
    const res = await fetch(url, { method: "POST", headers: { "Content-Type": "application/json" }, body: json });
    const text = await res.text();
    let data; try { data = JSON.parse(text); } catch { data = text; }
    log(`[Make ${tag}] HTTP ${res.status} resp(${text.length}B)`);
    return { ok: res.ok, data, status: res.status };
  } catch (e) { err(`[Make ${tag}]`, e?.message || e); return { ok: false, data: null, status: 0 }; }
}

// ============ OpenAI ============
async function openaiChat({ system, messages, temperature = 0.3, max_tokens = 180 }) {
  if (!OPENAI_API_KEY) throw new Error("OPENAI_API_KEY missing");
  const body = { model: "gpt-4o-mini", temperature, max_tokens, messages: [{ role: "system", content: system }, ...messages] };
  const res = await fetch("https://api.openai.com/v1/chat/completions", {
    method: "POST",
    headers: { Authorization: `Bearer ${OPENAI_API_KEY}`, "Content-Type": "application/json" },
    body: JSON.stringify(body)
  });
  if (!res.ok) throw new Error(`OpenAI ${res.status}: ${await res.text()}`);
  const json = await res.json();
  return json?.choices?.[0]?.message?.content || "";
}

function containsAny(s, arr) { s = (s || "").toLowerCase(); return arr.some(w => s.includes(w)); }

// Heuristic safety net for common FAQs and intents
function heuristicExtract(utterance) {
  const u = (utterance || "").toLowerCase();
  if (!u) return null;
  if (containsAny(u, ["price", "cost", "how much"])) return { intent: "FAQ", faq_topic: "PRICES", ask: "NONE" };
  if (containsAny(u, ["hour", "open", "close", "closing"])) return { intent: "FAQ", faq_topic: "HOURS", ask: "NONE" };
  if (containsAny(u, ["service", "offer", "do you do"])) return { intent: "FAQ", faq_topic: "SERVICES", ask: "NONE" };
  if (containsAny(u, ["where", "address", "located", "location"])) return { intent: "FAQ", faq_topic: "LOCATION", ask: "NONE" };
  if (containsAny(u, ["book", "schedule", "appointment", "reschedul", "cancel"])) return { intent: "CREATE", ask: "SERVICE" };
  return null;
}

async function extractTurn(utterance, mem, callId, forbidGreet, callerIdGuess) {
  const { nowISO, tz } = nowContext();

  const sys = `
Return ONLY JSON with this schema. Current time ${nowISO} ${tz}. Interpret dates in ${tz}. 30-min slots.

{
  "intent": "CREATE|READ|DELETE|FAQ|SMALLTALK|UNKNOWN",
  "faq_topic": string,
  "Event_Name": string,
  "Start_Time": string,
  "End_Time": string,
  "Customer_Name": string,
  "Customer_Phone": string,
  "Customer_Email": string,
  "id": string,
  "Notes": string,
  "window": { "start": string, "end": string },
  "ask": "NONE|SERVICE|TIME|NAME|PHONE|CONFIRM",
  "reply": string
}

Rules:
- Booking order: service → date/time → check → name & phone → confirm.
- Book only Mon–Fri 9–5 (${tz}). If outside hours, ask for in-hours time.
- If time is taken, propose two closest alternatives (earlier & later).
- FAQ topics: PRICES|HOURS|SERVICES|LOCATION.
- If caller agrees to book after FAQ, intent=CREATE and ask next missing step.
- No greetings when forbidGreet=true. Keep replies short (<20 words) and conversational; one question max.
- If callerIdGuess present, confirm it when asking for phone.
`.trim();

  const userMsg = `MEM:${JSON.stringify(mem)} CALL:${callId} forbidGreet=${!!forbidGreet} callerIdGuess=${callerIdGuess || ""}\nUSER:${utterance}`;
  const raw = await openaiChat({
    system: sys + "\n\n" + AGENT_PROMPT,
    messages: [{ role: "user", content: userMsg }],
    temperature: 0.2,
    max_tokens: 220
  });

  let out; try { out = JSON.parse(raw); } catch { out = { intent: "UNKNOWN", ask: "NONE", reply: "" }; }

  // Heuristic patch if model returns UNKNOWN for obvious FAQ/intent
  if (out.intent === "UNKNOWN") {
    const h = heuristicExtract(utterance);
    if (h) out = { ...out, ...h };
  }
  log("[extract JSON]", out);
  return out;
}

async function nlgLine(context, forbidGreet) {
  const sys = `
You are a warm front-desk receptionist.
Write ONE short, conversational sentence next (<=20 words).
Use contractions and small acks. Max ONE question.
NO greeting or business name if forbidGreet=true.
Avoid repeating the same wording. Be specific to current step.
`.trim();

  let content = await openaiChat({
    system: sys + "\n\n" + AGENT_PROMPT,
    messages: [{ role: "user", content: JSON.stringify({ ...context, forbidGreet: !!forbidGreet }) }],
    temperature: 0.5,
    max_tokens: 60
  });

  content = (content || "").replace(/\s+/g, " ").trim();

  // Strong client-side greeting filter (prevents loops like “Hi thanks…” mid-call)
  const greetRegex = /\b(hi|hello|hey|thanks for call(ing)?|old line barbershop)\b/i;
  if (forbidGreet && greetRegex.test(content)) {
    // Rephrase by removing greeting-y parts
    content = content.replace(/^(hi|hello|hey)[\s,!.]*/i, "");
    content = content.replace(/thanks for call(ing)?[^.?!]*[.?!]?\s*/i, "");
    content = content.replace(/old line barbershop/gi, "");
    content = content.trim();
    if (!content) content = "How can I help with that?";
  }
  return content;
}

// ============ TTS ============
async function speakEleven(ws, streamSid, text) {
  if (!streamSid || !text) return;
  if (!ELEVEN_API_KEY || !ELEVEN_VOICE_ID) { log("(!) ELEVEN vars missing — TTS skipped:", text); return; }

  log("[TTS ->]", text);
  let res;
  try {
    const url = `https://api.elevenlabs.io/v1/text-to-speech/${ELEVEN_VOICE_ID}/stream?optimize_streaming_latency=3&output_format=ulaw_8000`;
    res = await fetch(url, {
      method: "POST",
      headers: { "xi-api-key": ELEVEN_API_KEY, "Content-Type": "application/json" },
      body: JSON.stringify({ text, voice_settings: { stability: 0.45, similarity_boost: 0.8 } })
    });
  } catch (e) { err("[TTS] net", e?.message || e); return; }

  if (!res.ok || !res.body) { err("[TTS] HTTP", res.status, await res.text()); return; }

  return new Promise((resolve) => {
    res.body.on("data", (chunk) => {
      try {
        ws.send(JSON.stringify({ event: "media", streamSid, media: { payload: Buffer.from(chunk).toString("base64") } }));
      } catch (e) { err("[TTS ws send]", e?.message || e); }
    });
    res.body.on("end", () => { log("[TTS] end"); resolve(); });
  });
}

// ============ EXPRESS/WS (singletons) ============
const app = express();
app.get("/", (_,res)=>res.type("text/plain").send("OK"));
app.get("/twilio", (_,res)=>res.status(426).type("text/plain").send("Use wss://<host>/twilio"));

const server = http.createServer(app);
const wss = new WebSocketServer({ noServer: true, perMessageDeflate: false });

server.on("upgrade", (req, socket, head) => {
  const u = new URL(req.url, `http://${req.headers.host}`);
  if (u.pathname !== "/twilio") { socket.write("HTTP/1.1 404 Not Found\r\n\r\n"); return socket.destroy(); }
  wss.handleUpgrade(req, socket, head, (ws) => wss.emit("connection", ws, req));
});

// ============ Session ============
wss.on("connection", (ws) => {
  let streamSid = null;
  let callSid = null;
  let frames = 0;

  let greeted = false;
  let forbidGreet = false;
  let closed = false;

  let lastUserAt = Date.now();
  let lastSaid = ""; // anti-repeat

  const memory = { name: "", phone: "", email: "", service: "", startISO: "", endISO: "" };

  // keepalive
  ws.isAlive = true;
  ws.on("pong", () => { ws.isAlive = true; });
  const pingIv = setInterval(() => {
    if (ws.isAlive === false) { try { ws.terminate(); } catch {} return; }
    ws.isAlive = false;
    try { ws.ping(); } catch {}
  }, 25000);

  // inactivity reprompt (gentle, one line, no greet)
  const INACTIVITY_MS = 10000;
  const repromptIv = setInterval(async () => {
    if (closed) return;
    const idle = Date.now() - lastUserAt;
    if (idle < INACTIVITY_MS) return;

    let need = "";
    if (!memory.service) need = "Ask which service they want. Offer examples.";
    else if (!memory.startISO) need = "Ask date/time; suggest a specific example.";
    else if (!memory.name) need = "Ask for name.";
    else if (!memory.phone) need = "Ask for phone; confirm caller ID if known.";
    else need = "Confirm details in one sentence and ask permission to book.";

    const line = await nlgLine({ phase: "reprompt", memory, need }, true);
    await say(line, true);
  }, 3000);

  function digitsOnlyPhone(p) { return (p || "").replace(/\D+/g, "").slice(-10); }
  function formatPhone(d10) { return (d10 && d10.length === 10) ? `(${d10.slice(0,3)}) ${d10.slice(3,6)}-${d10.slice(6)}` : (d10 || ""); }

  function callerIdFromStart(evt) {
    const cp = evt?.start?.customParameters || {};
    const maybe = cp.caller || cp.from || cp.phone || cp.number || "";
    const d10 = digitsOnlyPhone(maybe);
    return d10 ? formatPhone(d10) : "";
  }

  async function say(text, allowSameOnce = false) {
    if (!text || closed) return;
    // anti-repeat
    const norm = text.toLowerCase().replace(/\s+/g, " ").trim();
    const same = norm && norm === lastSaid;
    if (same && !allowSameOnce) {
      // try a quick rephrase once
      const line2 = await nlgLine({ rephrase: text }, true);
      const norm2 = line2.toLowerCase().replace(/\s+/g, " ").trim();
      if (norm2 && norm2 !== lastSaid) {
        lastSaid = norm2;
        return speakEleven(ws, streamSid, line2);
      }
      // final fallback: tiny variation
      const tiny = text.endsWith("?") ? "Could you tell me more?" : "Got it.";
      lastSaid = tiny.toLowerCase();
      return speakEleven(ws, streamSid, tiny);
    }
    lastSaid = norm;
    return speakEleven(ws, streamSid, text);
  }

  async function finalizeAndHangup(line) {
    if (closed) return;
    closed = true;
    try { await say(line || "Thanks for calling. Goodbye."); } catch {}
    try { ws.send(JSON.stringify({ event: "stop", streamSid })); } catch {}
    cleanup();
    try { ws.close(); } catch {}
  }

  async function handleExtractionResult(ex, utterance, callerGuess) {
    // merge memory (context only)
    if (ex.Customer_Name)  memory.name = ex.Customer_Name.trim();
    if (ex.Customer_Phone) {
      const d = digitsOnlyPhone(ex.Customer_Phone);
      if (d) memory.phone = formatPhone(d);
    }
    if (ex.Customer_Email) memory.email = ex.Customer_Email;
    if (ex.Event_Name) {
      const s = String(ex.Event_Name).toLowerCase();
      if (s.includes("beard")) memory.service = "Beard Trim";
      else if (s.includes("hair")) memory.service = "haircut";
    }
    if (ex.Start_Time) memory.startISO = ex.Start_Time;
    if (ex.End_Time)   memory.endISO = ex.End_Time;

    // enforce hours if time already chosen
    if (memory.startISO && !isBusinessHours(memory.startISO)) {
      const line = await nlgLine({ gate: "outside_hours", tz: LOCAL_TZ }, true);
      return say(line);
    }

    // intent handling
    if (ex.intent === "FAQ") {
      if (ex.faq_topic) await callMake(MAKE_READ, { intent: "FAQ", topic: ex.faq_topic }, "FAQ");
      const line = ex.reply || await nlgLine({ faq: ex.faq_topic, memory }, true);
      return say(line);
    }

    if (ex.intent === "DELETE") {
      if (!ex.id) {
        const line = ex.reply || await nlgLine({ ask: "ID_TO_CANCEL" }, true);
        return say(line);
      }
      const r = await callMake(MAKE_DELETE, { id: ex.id }, "DELETE");
      const line = r.ok
        ? await nlgLine({ inform: "Cancelled. Thank and goodbye." }, true)
        : await nlgLine({ inform: "Couldn’t cancel. Offer to try again." }, true);
      return finalizeAndHangup(line);
    }

    if (ex.intent === "READ" && (ex.window?.start || memory.startISO)) {
      const win = ex.window?.start ? ex.window : { start: memory.startISO, end: memory.endISO || memory.startISO };
      const r = await callMake(MAKE_READ, { intent: "READ", window: win }, "READ");
      const count = Array.isArray(r?.data?.events) ? r.data.events.length : 0;
      const line = await nlgLine({ inform: `Found ${count} appointment(s).`, next: "Offer help." }, true);
      return say(line);
    }

    // CREATE / SMALLTALK / UNKNOWN -> step-by-step
    if (memory.service && memory.startISO && ex.ask !== "NAME" && ex.ask !== "PHONE") {
      // check conflict
      const win = { start: memory.startISO, end: memory.endISO || memory.startISO };
      const check = await callMake(MAKE_READ, { intent: "READ", window: win }, "READ-check");
      const events = Array.isArray(check?.data?.events) ? check.data.events : [];
      if (events.length) {
        const line = await nlgLine({ conflict: "time_taken", propose: "two_alternatives" }, true);
        return say(line);
      }
      if (!memory.name)  return say(await nlgLine({ ask: "NAME" }, true));
      if (!memory.phone) return say(await nlgLine({ ask: "PHONE", callerGuess }, true));
      // ask to confirm and book
      return say(await nlgLine({ ask: "CONFIRM", pretty: pretty(memory.startISO, LOCAL_TZ), memory }, true));
    }

    if (ex.ask && ex.ask !== "NONE") {
      const line = ex.reply || await nlgLine({ ask: ex.ask, memory }, true);
      return say(line);
    }

    // fallback next helpful line (NO greeting)
    const line = ex.reply || await nlgLine({ fallback: true, memory }, true);
    return say(line);
  }

  async function runCreateBookingIfConfirmed(utterance) {
    const yes = /\b(yes|yeah|yep|sure|please|go ahead|book it|confirm|sounds good|that works|okay|ok)\b/i.test(utterance || "");
    const no  = /\b(no|nah|nope|stop|wait|hold on|cancel|not now)\b/i.test(utterance || "");
    if (!yes && !no) return false;

    if (no) {
      const line = await nlgLine({ inform: "Not booking. Offer another time or service." }, true);
      await say(line);
      return true;
    }

    // YES → create booking
    const payload = {
      Event_Name: memory.service || "Appointment",
      Start_Time: memory.startISO,
      End_Time:   memory.endISO || "",
      Customer_Name:  memory.name,
      Customer_Phone: memory.phone,
      Customer_Email: memory.email || "",
      Notes: `Booked by phone agent. CallSid=${callSid}`
    };
    const when = pretty(memory.startISO, LOCAL_TZ);
    const r = await callMake(MAKE_CREATE, payload, "CREATE");
    if (r.ok) {
      const line = await nlgLine({ inform: `Booked for ${when}. Thank them and say goodbye.` }, true);
      await finalizeAndHangup(line);
    } else {
      const line = await nlgLine({ inform: "Couldn’t complete booking. Offer a different time." }, true);
      await say(line);
    }
    return true;
  }

  async function onUserUtterance(txt) {
    if (closed) return;
    lastUserAt = Date.now();

    // confirm step fast-path
    const handled = await runCreateBookingIfConfirmed(txt);
    if (handled) return;

    // extraction + step
    const callerGuess = memory.phone || "";
    const ex = await extractTurn(txt, memory, callSid, forbidGreet, callerGuess);
    await handleExtractionResult(ex, txt, callerGuess);
  }

  // ---------- WS messages ----------
  ws.on("message", async (buf) => {
    let evt; try { evt = JSON.parse(buf.toString()); } catch { return; }

    if (evt.event === "start") {
      streamSid = evt.start?.streamSid || null;
      callSid   = evt.start?.callSid || null;
      const biz = evt.start?.customParameters?.biz || "default";
      log("WS CONNECTED |", streamSid, "| CallSid:", callSid, "| biz:", biz);
      log("[agent] Using AGENT_PROMPT (first 120 chars):", (AGENT_PROMPT.slice(0,120) + "…"));

      const guess = callerIdFromStart(evt);
      if (guess) memory.phone = guess;

      // Deepgram
      const dg = startDeepgram({
        onOpen: () => log("[ASR] ready"),
        onPartial: () => { lastUserAt = Date.now(); },
        onFinal: (txt) => onUserUtterance(txt),
        onError: (e) => err("[ASR]", e?.message || e),
        onAny:   (m) => { if (m.type && m.type !== "Results") log("[ASR msg]", JSON.stringify(m)); }
      });
      ws._dg = dg;

      // single greeting at call start
      if (!greeted) {
        greeted = true;
        forbidGreet = false;
        await say("Hi, thanks for calling Old Line Barbershop. How can I help you today?");
        forbidGreet = true;
      }
    }

    else if (evt.event === "media") {
      if (!ws._dg) return;
      frames++;
      if (frames % 50 === 1) log("[media] frames:", frames);
      const b64 = evt.media?.payload;
      if (!b64) return;
      try {
        const ulaw = Buffer.from(b64, "base64");
        const pcm = ulawBufferToPCM16LEBuffer(ulaw);
        ws._dg.sendPCM16LE(pcm);
      } catch (e) { err("[media]", e?.message || e); }
    }

    else if (evt.event === "stop") {
      log("Twilio stream STOP");
      cleanup();
    }
  });

  function cleanup() {
    if (closed) return;
    try { ws._dg?.close(); } catch {}
    clearInterval(pingIv);
    clearInterval(repromptIv);
    log("WS closed");
  }

  ws.on("close", cleanup);
  ws.on("error", (e) => { err("WS error", e?.message || e); cleanup(); });
});

server.listen(PORT, () => log(`Server running on ${PORT}`));
